<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahindra : Explore Tractor 360 Experience</title>
    <style>
        /* Global styling for the body */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* Canvas styling - it is initially hidden */
        canvas {
            display: none; /* Initially hidden */
            width: 100%;
            height: 100vh;
        }

        /* Landing Page Styling */
        #landingPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* Align items to the bottom */
            align-items: center;
            background: url("res/landing/landing.jpeg") no-repeat center bottom;
            background-size: cover;
            text-align: center;
            z-index: 100;
            transition: opacity 1s ease-in-out; /* Smooth transition */
            opacity: 1;
            padding-bottom: 5vh; /* Adjusted padding from the bottom */
            box-sizing: border-box; /* Include padding within the element's total height */
        }

        #landingPage.hidden {
            opacity: 0;
            pointer-events: none; /* Disable interaction when hidden */
        }

        #landingPage h1 {
            font-size: 3rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            margin-bottom: 0.5rem;
        }

        #landingPage p {
            font-size: 1.2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            margin-bottom: 2rem;
        }

        #startButton {
            background: url("res/ui/enter.png") no-repeat center center;
            background-size: contain;
            border: none;
            width: 200px; /* Adjust size as needed */
            height: 50px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.3s ease;
            background-color: transparent;
        }

        #startButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        #startButton:active {
            transform: scale(0.98);
        }

        /* Video Overlay Styles */
        #videoOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200; /* Above everything else */
        }
        #videoContainer {
            position: relative;
            width: 80%; /* Adjust as needed */
            max-width: 800px; /* Max width for video */
            background-color: #000;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); /* Green glow */
            padding-bottom: 45%;
            height: 0;
        }
        #videoPlayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        #closeVideoBtn {
            position: absolute;
            top: -45px; /* Position it above the video container */
            right: 0px;
            background: url('res/ui/close.png') no-repeat center center;
            background-size: contain;
            border: none;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 210; /* Ensure it's above the video container */
            transition: transform 0.2s ease;
        }
        #closeVideoBtn:hover {
            transform: scale(1.1);
        }

        /* Hotspot icon styling */
        .hotspot-icon {
            background-color: rgba(255, 255, 0, 0.8);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: black;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
            transition: transform 0.2s ease;
        }
        .hotspot-icon:hover {
            transform: scale(1.2);
        }

        /* Instruction Popup Styles */
        #instructionPopupOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 250;
        }

        #instructionPopupContent {
            position: relative;
            width: 80vw; /* Use up to 80% of the viewport width */
            max-width: 600px; /* But no more than 600px */
            aspect-ratio: 1895 / 884; /* Maintain a 2:1 aspect ratio, matching the image */
            background: url('res/ui/instructions.png') no-repeat center center;
            background-size: cover; /* The image will cover the entire area without distortion */
        }

        #closeInstructionBtn {
            position: absolute;
            top: 13px; /* Position inside the top edge */
            right: 20px; /* Position inside the right edge */
            background: url('res/ui/close.png') no-repeat center center;
            background-size: contain;
            border: none;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 260;
            transition: transform 0.2s ease;
        }
        #closeInstructionBtn:hover {
            transform: scale(1.1);
        }

        /* New styles for the options popup */
        #optionsPopup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000; /* FLICKER FIX: Changed from white to black */
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: flex-end; /* Align content to the bottom */
            z-index: 150;
        }
        
        #popupContent {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Keep overflow hidden */
            display: flex;
            justify-content: center; /* Center horizontally */
            align-items: flex-end; /* Align to bottom */
            cursor: grab; /* Add grab cursor for dragging */
        }
        
        #popupContent.dragging {
            cursor: grabbing;
        }

        /* UPDATED: Style for the new video element (now hidden) */
        #popupVideo {
           display: none;
        }
        
        /* NEW: Style for the canvas that will display the video */
        #popupCanvas {
            width: 100%;
            height: auto;
            user-select: none;
        }


        #closePopupBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: url('res/ui/close.png') no-repeat center center;
            background-size: contain;
            border: none;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 160;
            transition: transform 0.2s ease;
        }
        #closePopupBtn:hover {
            transform: scale(1.1);
        }

        /* Styles for the new 2D hotspots on the popup image */
        #hotspot2DContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to popupHotspot and arrows */
        }
        .hotspot-2d {
            position: absolute;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: transform 0.2s ease;
            pointer-events: auto; /* Re-enable clicks for the hotspot itself */
            transform: translate(-50%, -50%); /* Center the hotspot icon on the specified coordinates */
        }
        .hotspot-2d img, .hotspot-2d video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none; /* Ensure clicks are registered on the parent div */
        }
        .hotspot-2d:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        /* Static 360 Icon */
        #static360Icon {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            z-index: 172; /* Changed from 110 to be on top of the popup */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            /*border-radius: 50%; */ /* Make it circular */
            overflow: hidden; /* Hide parts of the video outside the circle */
            /* box-shadow: 0 0 15px rgba(255, 255, 255, 0.3); *//* Optional: add a subtle glow */
        }

        #static360Icon video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures the video fills the container */
        }

        /* Styles for the text info box */
        #textInfoBox {
            position: absolute;
            top: 100px;
            left: 310px;
            width: 230px; /* Increased width for larger font */
            aspect-ratio: 735 / 463; /* IMPORTANT: Adjust this to match your info_box.png aspect ratio */
            background: url('res/ui/info_box.png') no-repeat center center;
            background-size: cover; /* Use 'cover' to fill the area without distorting the image */
            color: rgb(0, 0, 0);
            padding: 40px; /* Increased padding */
            z-index: 170;
            display: none; /* Hidden by default, will be set to 'flex' by JS */
            justify-content: center; /* Horizontally center content */
            align-items: center; /* Vertically center content */
            text-align: center; /* Center the text itself */
            animation: fadeIn 0.5s ease-in-out;
            box-sizing: border-box; /* Ensures padding is included in the element's total width/height */
            overflow-y: hidden; /* Changed from 'auto' to 'hidden' to remove scrollbar */
        }

        #textInfoBox p {
            margin: 0;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-weight: 600; /* Semi-Bold. Use 700 for Bold */
            font-size: 18px;
            line-height: 1.4; /* Adjusted for larger font size */
            white-space: pre-line; /* This will respect newline characters */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* MODIFIED: Hide the slider controls */
        #popupControls {
            display: none; 
        }
        
        .option-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 250px;
            height: 8px;
            background: #555;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 5px;
            margin: 0 15px;
        }

        .option-slider:hover {
            opacity: 1;
        }

        .option-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .option-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #333;
        }


        /* Styles for the new vertical toolbar */
        #verticalToolbar {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 40px; /* Adjusted spacing for smaller buttons */
            z-index: 171; /* Set to be on top of the options popup */
            background-color: white; /* Set background to white */
            padding: 15px; /* Added more padding */
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15); /* Added a subtle shadow */
        }

        .toolbar-btn {
            background-color: transparent;
            border: none;
            width: 30px; /* Made buttons smaller */
            height: 30px; /* Made buttons smaller */
            cursor: pointer;
            transition: transform 0.2s ease;
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain; /* Use contain to fit the whole image */
        }

        .toolbar-btn:hover {
            transform: scale(1.1);
        }

        /* Set specific background images for each button */
        #fullscreenBtn {
            background-image: url('res/ui/full_screen.png');
        }

        #zoomIn360Btn {
            background-image: url('res/ui/zoom_in.png');
        }

        #zoomOut360Btn {
            background-image: url('res/ui/zoom_out.png');
        }
        /* The sound button's image is set via JavaScript */

    </style>
</head>
<body>
    <div id="landingPage">
        <button id="startButton"></button>
    </div>

    <div id="instructionPopupOverlay">
        <div id="instructionPopupContent">
            <button id="closeInstructionBtn"></button>
        </div>
    </div>
    
    <div id="verticalToolbar">
        <button id="fullscreenBtn" class="toolbar-btn"></button>
        <button id="zoomIn360Btn" class="toolbar-btn"></button>
        <button id="zoomOut360Btn" class="toolbar-btn"></button>
        <button id="soundBtn" class="toolbar-btn"></button>
    </div>


    <div id="optionsPopup">
        <div id="popupContent">
            <!-- NEW: Canvas to display the video frames -->
            <canvas id="popupCanvas"></canvas>
            <!-- The video element is now hidden and used as a data source for the canvas -->
            <video id="popupVideo" src="res/3D/bonnet_close.webm" muted playsinline></video>
            
            <div id="hotspot2DContainer"></div>

            <div id="textInfoBox">
                <p id="textInfoContent"></p>
            </div>
            
            <button id="closePopupBtn"></button>

            <!-- The slider is now hidden and controlled by dragging -->
            <div id="popupControls">
                <input type="range" id="optionSlider" class="option-slider" value="0" min="0" max="100">
            </div>
        </div>
    </div>

    <div id="videoOverlay">
        <div id="videoContainer">
            <iframe id="videoPlayer" width="100%" height="100%" src="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            <button id="closeVideoBtn"></button>
        </div>
    </div>
    
    <div id="static360Icon">
        <video src="res/ui/360.webm" autoplay loop muted playsinline></video>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Declare global variables for the Three.js scene
        let scene, camera, renderer;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let sphere, material;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hotspotMeshes = [];
        let activeHotspotVideo = null; // To track the currently playing hotspot video
        
        // New video texture for 3D hotspots
        let hotspotVideoTexture = null;
        
        // Variables for popup content dragging (for panning when zoomed)
        let isPopupDragging = false;
        let startPopupDragX = 0;
        let startPopupDragY = 0;
        // NEW: Variable to store video time at the start of a drag
        let startVideoTimeOnDrag = 0;

        // Variables for zooming and panning
        let zoomLevel = 1;
        let maxZoom = 3;
        let minZoom = 1;
        let panX = 0;
        let panY = 0;
        let startPanX = 0;
        let startPanY = 0;

        // New variable for sound state
        let isSoundOn = false;
        let bonnetSound = null; // To hold the looping sound element

        // New timer for the auto-hiding text info box
        let textInfoTimer = null;
        
        // NEW: Variable to track the current scrubbable video
        let currentScrubbableVideo = 'res/3D/bonnet_close.webm';
        
        // NEW: Variables for canvas rendering
        let popupCanvas, ctx;
        let transitionAnimationId = null;

        // HTML elements
        const landingPage = document.getElementById('landingPage');
        const startButton = document.getElementById('startButton');
        const videoOverlay = document.getElementById('videoOverlay');
        const videoPlayer = document.getElementById('videoPlayer');
        const closeVideoBtn = document.getElementById('closeVideoBtn');
        const optionsPopup = document.getElementById('optionsPopup');
        const popupContent = document.getElementById('popupContent');
        const popupVideo = document.getElementById('popupVideo');
        const closePopupBtn = document.getElementById('closePopupBtn');
        const hotspot2DContainer = document.getElementById('hotspot2DContainer');
        const textInfoBox = document.getElementById('textInfoBox');
        const textInfoContent = document.getElementById('textInfoContent');
        const instructionPopupOverlay = document.getElementById('instructionPopupOverlay');
        const closeInstructionBtn = document.getElementById('closeInstructionBtn');
        const static360Icon = document.getElementById('static360Icon');
        const optionSlider = document.getElementById('optionSlider'); // Keep reference, though hidden
        
        // New Toolbar Elements
        const verticalToolbar = document.getElementById('verticalToolbar');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const zoomIn360Btn = document.getElementById('zoomIn360Btn');
        const zoomOut360Btn = document.getElementById('zoomOut360Btn');
        const soundBtn = document.getElementById('soundBtn');


        // Direct URLs for panoramic images and assets
        const panorama1ImageUrl = "res/nav/1.png";
        const panorama2ImageUrl = "res/nav/2.png";
        const panorama3ImageUrl = "res/nav/3.png";

        // Data structure for panoramic images and their hotspots
        const panoData = [
            { name: "Panorama 1", imageUrl: panorama1ImageUrl, hotspots: [{ id: "nextPanoArrow1", position: new THREE.Vector3(80, -20, 0), rotation: new THREE.Vector3(0, Math.PI / 2, 0), type: "arrow", targetPanoIndex: 1, label: "Next" }] },
            { name: "Panorama 2", imageUrl: panorama2ImageUrl, hotspots: [{ id: "nextPanoArrow2", position: new THREE.Vector3(80, -20, 0), rotation: new THREE.Vector3(0, Math.PI / 2, 0), type: "arrow", targetPanoIndex: 2, label: "Next" }, { id: "backPanoArrow2", position: new THREE.Vector3(-80, -20, 0), rotation: new THREE.Vector3(0, -Math.PI / 2, 0), type: "arrow", targetPanoIndex: 0, label: "Back" }] },
            { name: "Panorama 3", imageUrl: panorama3ImageUrl, hotspots: [{ id: "popupHotspot3D", position: new THREE.Vector3(80, -25,0), type: "popup", label: "Explore Tractor" }, { id: "backPanoArrow", position: new THREE.Vector3(-80, -20, 0), rotation: new THREE.Vector3(0, -Math.PI / 2, 0), type: "arrow", targetPanoIndex: 1, label: "Back" }] }
        ];

        // NEW: Centralized hotspot configuration
        const hotspotConfigurations = {
            'res/3D/bonnet_close.webm': {
                type: 'slider',
                options: [
                    { 
                        range: [90, 99], 
                        hotspots: [
                            { x: 40, y: 72, label: "A", type: "text_info", text:"Turning Radius\n2.3 Mtrs" },
                            { x: 52, y: 52, label: "B", type: "text_info", text: "Battery\n88 Amp x 12 volt" },
                            { x: 43, y: 45, label: "C", type: "text_info", text: "Headlamps\nTrapezoidal Clear\nLense" }
                        ] 
                    },
                    { 
                        range: [0, 5], 
                        hotspots: [
                            { x: 40, y: 72, label: "A", type: "text_info", text:"Turning Radius\n2.3 Mtrs" },
                            { x: 52, y: 52, label: "B", type: "text_info", text: "Battery\n88 Amp x 12 volt" },
                            { x: 43, y: 45, label: "C", type: "text_info", text: "Headlamps\nTrapezoidal Clear\nLense" }
                        ] 
                    },
                    { 
                        range: [20, 25], 
                        hotspots: [
                            {
                              x: 66, y: 37, label: "A", type: "image_sequence_with_path_change", 
                              soundUrl: "res/ui/bonnet_clip.mp3",
                              transitionVideo: "res/3D/bonnet_open.webm",
                              nextScrubbableVideo: "res/3D/bonnet_open_360.webm"
                            },
                            { x: 69, y: 58, label: "C", type: "text_info", text: "Front Tyre Size\n7.15 x 16" },
                            { x: 47, y: 58, label: "D", type: "text_info", text: "PCM\nTransmission" },
                            { x: 34, y: 50, label: "E", type: "text_info", text: "Rear Tyre Size\n14.9 x 28" },
                        ] 
                    },
                    { 
                        range: [30, 35], 
                        hotspots: [
                            { x: 57.5, y: 29, label: "A", type: "text_info", text:"Wet Type\nAir Filter" },
                            { x: 54, y: 56, label: "B", type: "text_info", text: "Dual\nClutch" },
                            { x: 68, y: 65, label: "C", type: "text_info", text: "Oil\nImmersed\nBrakes" }
                        ] 
                    },
                    { 
                        range: [49, 52], 
                        hotspots: [
                            { x: 55, y: 45, label: "A", type: "text_info", text:"Engine CC\n2979" },
                            { x: 54, y: 64, label: "B", type: "text_info", text: "PTO HP\n44.9" },
                            { x: 49, y: 55, label: "C", type: "text_info", text: "Hydraulic\nLift Capacity\n2000 Kg" }
                        ] 
                    }
                ]
            },
            'res/3D/bonnet_open_360.webm': {
                type: 'slider',
                options: [
                    { 
                        range: [0, 10], 
                        hotspots: [
                            { x: 32, y: 92, label: "A", type: "text_info", text:"Turning Radius\n2.3 Mtrs" },
                            { x: 51.5, y: 60, label: "B", type: "text_info", text: "Battery\n88 Amp x 12 volt" },
                            { x: 39, y: 43, label: "C", type: "text_info", text: "Headlamps\nTrapezoidal Clear\nLense" }
                        ] 
                    },
                    { 
                        range: [20, 30], 
                        hotspots: [
                            {
                              x: 70, y: 31, label: "A", type: "image_sequence_with_path_change", 
                              soundUrl: "res/ui/bonnet_clip.mp3",
                              transitionVideo: "res/3D/bonnet_close_anim.webm",
                              nextScrubbableVideo: "res/3D/bonnet_close.webm"
                            },
                            { x: 79, y: 62, label: "C", type: "text_info", text: "Front Tyre Size\n7.15 x 16" },
                            { x: 45, y: 65, label: "D", type: "text_info", text: "PCM\nTransmission" },
                            { x: 28, y: 55, label: "E", type: "text_info", text: "Rear Tyre Size\n14.9 x 28" },
                        ] 
                    },
                    { 
                        range: [50, 60], 
                        hotspots: [
                            { x: 62, y: 25, label: "A", type: "text_info", text:"Wet Type\nAir Filter" },
                            { x: 56, y: 61, label: "B", type: "text_info", text: "Dual\nClutch" },
                            { x: 75, y: 75, label: "C", type: "text_info", text: "Oil\nImmersed\nBrakes" }
                        ] 
                    }
                ]
            }
        };

        
        /**
         * Handles mouse wheel events for zooming.
         */
        function onMouseWheel(event) {
            event.preventDefault();
            const zoomSpeed = 1.5;
            camera.fov += event.deltaY * 0.05 * zoomSpeed;
            camera.fov = Math.max(10, Math.min(60, camera.fov));
            camera.updateProjectionMatrix();
        }

        /**
         * Handles the mouse down event to start dragging.
         */
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        /**
         * Handles the mouse up event to stop dragging.
         */
        function onMouseUp(event) {
            isDragging = false;
        }

        /**
         * Handles the mouse move event to rotate the camera when dragging.
         */
        function onMouseMove(event) {
            if (!isDragging) return;
            const deltaX = event.clientX - previousMousePosition.x;
            const horizontalRotationSpeed = 0.005;
            camera.rotation.y -= deltaX * horizontalRotationSpeed;
            camera.rotation.x = 0;
            camera.rotation.z = 0;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        /**
         * Handles clicks on the canvas for hotspot interaction.
         */
        function onCanvasClick(event) {
            if (optionsPopup.style.display === 'flex' || videoOverlay.style.display === 'flex') return;
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hotspotMeshes, true);
            if (intersects.length > 0) {
                let clickedHotspot = intersects[0].object;
                while (clickedHotspot.parent && hotspotMeshes.indexOf(clickedHotspot) === -1) {
                    clickedHotspot = clickedHotspot.parent;
                }
                const hotspotData = clickedHotspot.userData;
                if (hotspotData && hotspotData.type === "arrow" && hotspotData.targetPanoIndex !== undefined) {
                    loadPanoramicImage(panoData[hotspotData.targetPanoIndex].imageUrl, hotspotData.targetPanoIndex);
                } else if (hotspotData && hotspotData.type === "video" && hotspotData.videoUrl) {
                    showVideo(hotspotData.videoUrl);
                } else if (hotspotData && hotspotData.type === "popup") {
                    showOptionsPopup();
                }
            }
        }

        /**
         * Handles the touch start event.
         */
        function onTouchStart(event) {
            if (optionsPopup.style.display === 'flex' || videoOverlay.style.display === 'flex') return;
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        /**
         * Handles the touch end event.
         */
        function onTouchEnd(event) {
            if (optionsPopup.style.display === 'flex' || videoOverlay.style.display === 'flex') return;
            isDragging = false;
            if (event.changedTouches.length > 0) {
                onCanvasClick({ clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY });
            }
        }

        /**
         * Handles the touch move event.
         */
        function onTouchMove(event) {
            if (optionsPopup.style.display === 'flex' || videoOverlay.style.display === 'flex') return;
            if (!isDragging || event.touches.length !== 1) return;
            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const horizontalRotationSpeed = 0.005;
            camera.rotation.y -= deltaX * horizontalRotationSpeed;
            camera.rotation.x = 0;
            camera.rotation.z = 0;
            previousMousePosition.x = event.touches[0].clientX;
            previousMousePosition.y = event.touches[0].clientY;
            event.preventDefault();
        }
        
        /**
         * MODIFIED: Handles mouse down for both panning (when zoomed) and video scrubbing.
         */
        function onPopupMouseDown(event) {
            if (event.target.classList.contains('hotspot-2d')) return;
            
            isPopupDragging = true;
            startPopupDragX = event.clientX;
            startPopupDragY = event.clientY;
            popupContent.classList.add('dragging');

            if (zoomLevel > 1) {
                // Logic for panning when zoomed in
                startPanX = panX;
                startPanY = panY;
            } else {
                // Logic for scrubbing video when not zoomed
                startVideoTimeOnDrag = popupVideo.currentTime;
            }
        }


        /**
         * Handles the mouse up event for the popup video.
         */
        function onPopupMouseUp(event) {
            isPopupDragging = false;
            popupContent.classList.remove('dragging');
        }
        
        /**
         * MODIFIED: Handles mouse move for both panning and video scrubbing with seamless looping.
         */
        function onPopupMouseMove(event) {
            if (!isPopupDragging) return;

            if (zoomLevel > 1) {
                // Panning logic (existing)
                const deltaX = event.clientX - startPopupDragX;
                const deltaY = event.clientY - startPopupDragY;
                panX = startPanX + deltaX;
                panY = startPanY + deltaY;
                drawVideoFrame(); // Redraw canvas with new pan
            } else {
                // Scrubbing logic
                if (!popupVideo.duration || popupVideo.seeking) return; // Don't do anything if video is busy

                const deltaX = event.clientX - startPopupDragX;
                // Sensitivity: dragging across half the screen width scrubs the whole video
                const sensitivity = (popupVideo.duration / popupCanvas.width) * 2;
                let newTime = startVideoTimeOnDrag + deltaX * sensitivity;

                // NEW: Seamless looping logic
                if (popupVideo.duration) {
                    newTime = newTime % popupVideo.duration;
                    if (newTime < 0) {
                        newTime += popupVideo.duration;
                    }
                }

                // Only update if the time has changed to avoid flooding seek requests
                if (Math.abs(newTime - popupVideo.currentTime) > 0.01) {
                    popupVideo.currentTime = newTime;
                    
                    // Update hotspots based on the new video position (as a percentage)
                    const percentage = (newTime / popupVideo.duration) * 100;
                    updateHotspotsForVideo(percentage);
                    // The 'seeked' event listener will handle drawing the new frame
                }
            }
        }
        
        /**
         * Handles the touch start event for the popup video.
         */
        function onPopupTouchStart(event) {
            if (event.touches.length === 1 && !event.target.classList.contains('hotspot-2d')) {
                isPopupDragging = true;
                startPopupDragX = event.touches[0].clientX;
                startPopupDragY = event.touches[0].clientY;
                
                if (zoomLevel > 1) {
                    startPanX = panX;
                    startPanY = panY;
                } else {
                    startVideoTimeOnDrag = popupVideo.currentTime;
                }
            }
        }
        
        /**
         * Handles the touch end event for the popup video.
         */
        function onPopupTouchEnd(event) {
            isPopupDragging = false;
        }

        /**
         * MODIFIED: Handles touch move for both panning and video scrubbing with seamless looping.
         */
        function onPopupTouchMove(event) {
            if (!isPopupDragging || event.touches.length !== 1) return;
            event.preventDefault();

            if (zoomLevel > 1) {
                const deltaX = event.touches[0].clientX - startPopupDragX;
                const deltaY = event.touches[0].clientY - startPopupDragY;
                // BUG FIX: Correctly update panX with deltaX
                panX = startPanX + deltaX;
                panY = startPanY + deltaY;
                drawVideoFrame();
            } else {
                 if (!popupVideo.duration || popupVideo.seeking) return;

                const deltaX = event.touches[0].clientX - startPopupDragX;
                const sensitivity = (popupVideo.duration / popupCanvas.width) * 2;
                let newTime = startVideoTimeOnDrag + deltaX * sensitivity;
                
                // NEW: Seamless looping logic
                if (popupVideo.duration) {
                    newTime = newTime % popupVideo.duration;
                    if (newTime < 0) {
                        newTime += popupVideo.duration;
                    }
                }

                if (Math.abs(newTime - popupVideo.currentTime) > 0.01) {
                    popupVideo.currentTime = newTime;
                    const percentage = (newTime / popupVideo.duration) * 100;
                    updateHotspotsForVideo(percentage);
                }
            }
        }

        /**
         * Initializes the 360-degree image viewer.
         */
        function init() {
            // NEW: Initialize canvas elements
            popupCanvas = document.getElementById('popupCanvas');
            ctx = popupCanvas.getContext('2d');

            const hotspotVideo = document.createElement('video');
            hotspotVideo.src = 'res/ui/hotspot.webm';
            hotspotVideo.loop = true;
            hotspotVideo.muted = !isSoundOn;
            hotspotVideo.playsInline = true;
            hotspotVideo.play();
            hotspotVideoTexture = new THREE.VideoTexture(hotspotVideo);
            
            bonnetSound = new Audio('res/ui/bonnet_clip.mp3');
            bonnetSound.loop = true;

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0);
            camera.rotation.y = -Math.PI / 2;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            renderer.domElement.style.display = 'block';

            const geometry = new THREE.SphereGeometry(100, 60, 40);
            material = new THREE.MeshBasicMaterial({ side: THREE.BackSide });
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);

            loadPanoramicImage(panoData[0].imageUrl, 0);

            // Event Listeners
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onCanvasClick);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            renderer.domElement.addEventListener('touchmove', onTouchMove);

            window.addEventListener('resize', onWindowResize, false);
            closeVideoBtn.addEventListener('click', hideVideo);
            closePopupBtn.addEventListener('click', hideOptionsPopup);
            
            // REMOVED: Slider event listener is no longer needed
            // optionSlider.addEventListener('input', onSliderChange);
            
            // NEW: Add a persistent listener to draw frames efficiently after a seek operation
            popupVideo.addEventListener('seeked', drawVideoFrame);
            
            popupContent.addEventListener('mousedown', onPopupMouseDown);
            popupContent.addEventListener('mouseup', onPopupMouseUp);
            popupContent.addEventListener('mousemove', onPopupMouseMove);
            popupContent.addEventListener('mouseleave', onPopupMouseUp);
            popupContent.addEventListener('touchstart', onPopupTouchStart);
            popupContent.addEventListener('touchend', onPopupTouchEnd);
            popupContent.addEventListener('touchmove', onPopupTouchMove);

            closeInstructionBtn.addEventListener('click', hideInstructionPopup);
            
            fullscreenBtn.addEventListener('click', toggleFullScreen);
            zoomIn360Btn.addEventListener('click', zoomIn360);
            zoomOut360Btn.addEventListener('click', zoomOut360);
            soundBtn.addEventListener('click', toggleSound);

            document.querySelectorAll('#static360Icon video').forEach(video => {
                video.addEventListener('ended', function() { this.play().catch(e => {}); });
            });
            updateSoundButton();
        }

        /**
         * Adjusts the camera aspect ratio and renderer size on window resize.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Loads a new panoramic image and applies it to the sphere, and updates hotspots.
         */
        function loadPanoramicImage(imageUrl, panoIndex) {
            hotspotMeshes.forEach(mesh => scene.remove(mesh));
            hotspotMeshes = [];
            new THREE.TextureLoader().load(imageUrl, (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.repeat.x = -1;
                material.map = texture;
                material.needsUpdate = true;
                const currentPano = panoData[panoIndex];
                if (currentPano && currentPano.hotspots) {
                    currentPano.hotspots.forEach(createHotspot);
                }},
                undefined,
                (error) => {
                    console.error('An error occurred loading the texture:', error);
                    material.map = null;
                    material.color.setHex(0x1a1a1a);
                    material.needsUpdate = true;
                }
            );
        }

        /**
         * Creates a canvas element with text drawn on it.
         */
        function createTextCanvas(text, opts) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const font = `${opts.fontSize || 24}px ${opts.fontFace || 'Arial'}`;
            context.font = font;
            const metrics = context.measureText(text);
            canvas.width = metrics.width;
            canvas.height = opts.fontSize || 24;
            context.font = font;
            context.fillStyle = opts.color || 'black';
            context.fillText(text, 0, (opts.fontSize || 24) * 0.85);
            return canvas;
        }

        /**
         * Creates a 3D hotspot mesh and adds it to the scene.
         */
        function createHotspot(hotspotData) {
            let hotspotObject;
            if (hotspotData.type === "arrow") {
                const arrowVideo = document.createElement('video');
                arrowVideo.src = 'res/ui/nav_arrow.webm';
                arrowVideo.loop = true;
                arrowVideo.muted = true;
                arrowVideo.playsInline = true;
                arrowVideo.play().catch(e => console.error("Autoplay failed for arrow video", e));
                const arrowVideoTexture = new THREE.VideoTexture(arrowVideo);
                const hotspotGeometry = new THREE.PlaneGeometry(15, 10);
                const hotspotMaterial = new THREE.MeshBasicMaterial({ map: arrowVideoTexture, transparent: true, side: THREE.DoubleSide });
                hotspotMaterial.onBeforeCompile = (shader) => {
                    shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>', `
                        #ifdef USE_MAP
                            vec4 texelColor = texture2D( map, vUv );
                            texelColor = mapTexelToLinear( texelColor );
                            float luma = dot(texelColor.rgb, vec3(0.299, 0.587, 0.114));
                            if (luma < 0.2) discard;
                            diffuseColor *= texelColor;
                        #endif
                    `);
                };
                hotspotObject = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
                if (hotspotData.rotation) {
                    hotspotObject.rotation.set(Math.PI / 2, 0, hotspotData.rotation.z);
                }
            } else {
                // ===== FIX START: Unify Hotspot Rendering =====
                // The previous 'AdditiveBlending' caused artifacts on compressed videos.
                // This new method uses the same custom shader as the navigation arrows.
                // It calculates the brightness (luma) of each pixel and makes dark pixels
                // (like the black background) fully transparent, resulting in a clean cutout.
                const spriteMaterial = new THREE.SpriteMaterial({ map: hotspotVideoTexture, transparent: true, depthWrite: false });
                spriteMaterial.onBeforeCompile = (shader) => {
                    shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>', `
                        #ifdef USE_MAP
                            vec4 texelColor = texture2D( map, vUv );
                            texelColor = mapTexelToLinear( texelColor );
                            // Calculate brightness (luma) and discard dark pixels to remove the black background
                            float luma = dot(texelColor.rgb, vec3(0.299, 0.587, 0.114));
                            if (luma < 0.2) discard; // Adjusted threshold for cleaner edge
                            diffuseColor *= texelColor;
                        #endif
                    `);
                };
                hotspotObject = new THREE.Sprite(spriteMaterial);
                hotspotObject.scale.set(5, 5, 1);
                // ===== FIX END =====
            }

            if (hotspotData.label && hotspotData.type !== 'arrow') {
                const textCanvas = createTextCanvas(hotspotData.label, { color: 'black', fontSize: 30 });
                const textTexture = new THREE.CanvasTexture(textCanvas);
                const textMaterial = new THREE.SpriteMaterial({ map: textTexture, transparent: true });
                const textSprite = new THREE.Sprite(textMaterial);
                textSprite.scale.set(textCanvas.width / 10, textCanvas.height / 10, 1);
                textSprite.position.y = -5;
                const group = new THREE.Group();
                group.add(hotspotObject);
                group.add(textSprite);
                group.position.copy(hotspotData.position);
                group.userData = hotspotData;
                scene.add(group);
                hotspotMeshes.push(group);
            } else {
                hotspotObject.position.copy(hotspotData.position);
                hotspotObject.userData = hotspotData;
                scene.add(hotspotObject);
                hotspotMeshes.push(hotspotObject);
            }
        }

        /**
         * Shows the video overlay and plays the specified video.
         */
        function showVideo(videoUrl) {
            let embedUrl = videoUrl;
            if (videoUrl.includes('youtu.be') || videoUrl.includes('youtube.com')) {
                const match = videoUrl.match(/(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})/i);
                if (match && match[1]) {
                    embedUrl = `https://www.youtube.com/embed/${match[1]}?autoplay=1&rel=0`;
                } else {
                    console.error("Invalid YouTube URL:", videoUrl);
                    return;
                }
            }
            videoPlayer.src = embedUrl;
            videoOverlay.style.display = 'flex';
            static360Icon.style.opacity = '0';
            verticalToolbar.style.display = 'none';
        }

        /**
         * Hides the video overlay.
         */
        function hideVideo() {
            videoPlayer.src = '';
            videoOverlay.style.display = 'none';
            static360Icon.style.opacity = '1';
            verticalToolbar.style.display = 'flex';
        }

        /**
         * Shows the instruction popup.
         */
        function showInstructionPopup() {
            instructionPopupOverlay.style.display = 'flex';
        }

        /**
         * Hides the instruction popup.
         */
        function hideInstructionPopup() {
            instructionPopupOverlay.style.display = 'none';
            static360Icon.style.opacity = '1';
            verticalToolbar.style.display = 'flex';
        }

        /**
         * MODIFIED: Shows the options popup and prepares the video for scrubbing.
         */
        function showOptionsPopup() {
            optionsPopup.style.display = 'flex';
            popupCanvas.style.display = 'block'; // Make canvas visible
            
            // Reset to the default closed bonnet state every time
            currentScrubbableVideo = 'res/3D/bonnet_close.webm';
            popupVideo.src = currentScrubbableVideo;

            const setupVideoAndCanvas = () => {
                // Set canvas size to match video aspect ratio
                popupCanvas.width = popupVideo.videoWidth;
                popupCanvas.height = popupVideo.videoHeight;

                // Set currentTime to 0 to trigger the initial seek.
                popupVideo.currentTime = 0;
                // The persistent 'seeked' listener from init() will handle drawing the first frame.
                
                // Update hotspots for the initial position (0%).
                updateHotspotsForVideo(0);
                
                hotspot2DContainer.style.display = 'block';
                
                // Clean up the metadata listener
                popupVideo.onloadedmetadata = null;
            };

            // Wait for the video metadata to load before setting up the canvas and seeking.
            if (popupVideo.readyState >= 1) { // readyState >= HAVE_METADATA
                setupVideoAndCanvas();
            } else {
                popupVideo.onloadedmetadata = setupVideoAndCanvas;
            }
            
            static360Icon.style.opacity = '1';
        }

        /**
         * Hides the options popup.
         */
        function hideOptionsPopup() {
            optionsPopup.style.display = 'none';
            popupCanvas.style.display = 'none'; // Hide canvas
            hideTextInfo();
            static360Icon.style.opacity = '1';
            verticalToolbar.style.display = 'flex';
            
            // Cancel any pending video transitions
            if (transitionAnimationId) {
                cancelAnimationFrame(transitionAnimationId);
                transitionAnimationId = null;
            }
            popupVideo.onended = null;
            popupVideo.onloadedmetadata = null;


            if (bonnetSound) {
                bonnetSound.pause();
                bonnetSound.currentTime = 0;
            }

            if (activeHotspotVideo) {
                activeHotspotVideo.style.display = 'none';
                activeHotspotVideo.pause();
                const siblingImg = activeHotspotVideo.parentElement.querySelector('img');
                if (siblingImg) siblingImg.style.display = 'block';
                activeHotspotVideo = null;
            }

            // Reset zoom and pan
            zoomLevel = 1;
            panX = 0;
            panY = 0;
        }
        
        /**
         * Plays a sound file if sound is enabled.
         */
        function playSound(url) {
            if (!isSoundOn || !url) return;
            const audio = new Audio(url);
            audio.play().catch(e => console.error("Error playing sound:", e));
        }

        /**
         * Creates 2D hotspots for the current video frame.
         */
        function create2DHotspots(hotspotsData) {
            hotspotsData.forEach(hotspotData => {
                const hotspotElement = document.createElement('div');
                hotspotElement.className = 'hotspot-2d';
                hotspotElement.style.left = `${hotspotData.x}%`;
                hotspotElement.style.top = `${hotspotData.y}%`;
                hotspotElement.title = hotspotData.label;
                
                const hotspotImage = document.createElement('img');
                hotspotImage.src = (hotspotData.type === "image_sequence_with_path_change") ? 'res/ui/hotspot_bonnet.png' : 'res/ui/hotspot_normal.png';
                hotspotImage.style.display = 'block';
                hotspotElement.appendChild(hotspotImage);

                const hotspotVideo = document.createElement('video');
                hotspotVideo.src = (hotspotData.type === "image_sequence_with_path_change") ? 'res/ui/hotspot.webm' : 'res/ui/hotspot_optionspopup.webm';
                hotspotVideo.loop = true;
                hotspotVideo.muted = true;
                hotspotVideo.playsInline = true;
                hotspotVideo.style.display = 'none';
                hotspotElement.appendChild(hotspotVideo);

                hotspotElement.addEventListener('click', () => {
                    if (activeHotspotVideo && activeHotspotVideo !== hotspotVideo) {
                        activeHotspotVideo.style.display = 'none';
                        activeHotspotVideo.pause();
                        const siblingImg = activeHotspotVideo.parentElement.querySelector('img');
                        if (siblingImg) siblingImg.style.display = 'block';
                    }

                    hotspotImage.style.display = 'none';
                    hotspotVideo.style.display = 'block';
                    hotspotVideo.currentTime = 0;
                    hotspotVideo.play();
                    activeHotspotVideo = hotspotVideo;

                    if (hotspotData.type === "image_sequence_with_path_change") {
                        if (hotspotData.transitionVideo && hotspotData.nextScrubbableVideo) {
                            playTransitionVideo(hotspotData);
                        }
                    } else if (hotspotData.type === "text_info") {
                        showTextInfo(hotspotData.text);
                    }
                });

                hotspot2DContainer.appendChild(hotspotElement);
            });
        }
        
        /**
         * FLICKER FIX: Plays a transition video, preloads the next video, 
         * and then switches to it seamlessly.
         */
        function playTransitionVideo(hotspotData) {
            optionSlider.style.display = 'none';
            hotspot2DContainer.style.display = 'none';

            if (hotspotData.soundUrl) playSound(hotspotData.soundUrl);

            // 1. Play the transition video on the main video element
            popupVideo.loop = false;
            popupVideo.src = hotspotData.transitionVideo;
            popupVideo.muted = !isSoundOn;
            popupVideo.play();
            
            // 2. Start animation loop to draw the transition video frames on the canvas
            const animateTransition = () => {
                drawVideoFrame();
                transitionAnimationId = requestAnimationFrame(animateTransition);
            };
            animateTransition();

            // 3. When the transition video ends...
            popupVideo.onended = () => {
                // Stop the animation loop for the transition video
                if (transitionAnimationId) {
                    cancelAnimationFrame(transitionAnimationId);
                    transitionAnimationId = null;
                }

                // 4. Preload the *next* scrubbable video in a temporary, hidden video element
                const preloader = document.createElement('video');
                preloader.src = hotspotData.nextScrubbableVideo;
                
                // 5. When the preloader has enough data to play...
                preloader.onloadeddata = () => {
                    // 6. NOW, switch the main video element's source. It's already cached.
                    currentScrubbableVideo = hotspotData.nextScrubbableVideo;
                    popupVideo.src = currentScrubbableVideo;
                    
                    // 7. Setup the new video for scrubbing
                    const setupNewScrubbableVideo = () => {
                        popupCanvas.width = popupVideo.videoWidth;
                        popupCanvas.height = popupVideo.videoHeight;
                        
                        popupVideo.currentTime = 0; // This will trigger 'seeked' event
                        updateHotspotsForVideo(0);

                        hotspot2DContainer.style.display = 'block';
                        
                        popupVideo.onloadedmetadata = null;
                    };

                    // Check if metadata is ready, otherwise wait for it
                    if (popupVideo.readyState >= 1) {
                        setupNewScrubbableVideo();
                    } else {
                        popupVideo.onloadedmetadata = setupNewScrubbableVideo;
                    }
                    
                    popupVideo.onended = null; // Clean up the onended listener
                };
            };
        }


        /**
         * MODIFIED: Updates hotspots based on the video's current position percentage.
         */
        function updateHotspotsForVideo(videoPercentage) {
            hotspot2DContainer.innerHTML = '';
            
            const config = hotspotConfigurations[currentScrubbableVideo];
            if (!config) return;

            if (config.type === 'static') {
                create2DHotspots(config.hotspots);
            } else if (config.type === 'slider') {
                // Find hotspots based on the video's progress percentage
                const option = config.options.find(opt => videoPercentage >= opt.range[0] && videoPercentage <= opt.range[1]);
                if (option && option.hotspots) {
                    create2DHotspots(option.hotspots);
                }
            }
        }

        /**
         * Shows the text info box with a given text.
         */
        function showTextInfo(text) {
            if (textInfoTimer) clearTimeout(textInfoTimer);
            textInfoContent.textContent = text;
            textInfoBox.style.display = 'flex';
            textInfoTimer = setTimeout(hideTextInfo, 5000);
        }

        /**
         * Hides the text info box.
         */
        function hideTextInfo() {
            textInfoBox.style.display = 'none';
        }

        // REMOVED: The onSliderChange and animateScrub functions are no longer needed
        // as scrubbing is handled by direct mouse dragging.

        
        /**
         * NEW: Draws the current video frame to the canvas, applying zoom and pan.
         */
        function drawVideoFrame() {
            if (!popupCanvas.width || !popupCanvas.height || !popupVideo.videoWidth || !popupVideo.videoHeight) {
                return;
            }
            
            // FLICKER FIX: Set fillStyle to black to match the new background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, popupCanvas.width, popupCanvas.height);

            const sWidth = popupVideo.videoWidth / zoomLevel;
            const sHeight = popupVideo.videoHeight / zoomLevel;
            let sx = (popupVideo.videoWidth - sWidth) / 2 - panX;
            let sy = (popupVideo.videoHeight - sHeight) / 2 - panY;

            sx = Math.max(0, Math.min(sx, popupVideo.videoWidth - sWidth));
            sy = Math.max(0, Math.min(sy, popupVideo.videoHeight - sHeight));
            panX = (popupVideo.videoWidth - sWidth) / 2 - sx;
            panY = (popupVideo.videoHeight - sHeight) / 2 - sy;


            ctx.drawImage(
                popupVideo,
                sx, sy, sWidth, sHeight,
                0, 0, popupCanvas.width, popupCanvas.height
            );
        }


        /**
         * The main animation loop.
         */
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        /**
         * Function to be called when the start button is clicked.
         */
        function startExperience() {
            landingPage.classList.add('hidden');
            init();
            animate();
            showInstructionPopup();
        }
        
        /**
         * NEW: Toggles fullscreen mode for the entire page.
         */
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.warn(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        /**
         * Zooms into the 360-degree scene or the options popup.
         */
        function zoomIn360() {
            if (optionsPopup.style.display === 'flex') {
                if (zoomLevel < maxZoom) {
                    zoomLevel = Math.min(maxZoom, zoomLevel + 0.5);
                    drawVideoFrame();
                }
            } else {
                camera.fov = Math.max(10, camera.fov - 5);
                camera.updateProjectionMatrix();
            }
        }

        /**
         * Zooms out of the 360-degree scene or the options popup.
         */
        function zoomOut360() {
            if (optionsPopup.style.display === 'flex') {
                if (zoomLevel > minZoom) {
                    zoomLevel = Math.max(minZoom, zoomLevel - 0.5);
                    if (zoomLevel === 1) {
                        panX = 0;
                        panY = 0;
                    }
                    drawVideoFrame();
                }
            } else {
                camera.fov = Math.min(60, camera.fov + 5);
                camera.updateProjectionMatrix();
            }
        }

        /**
         * Toggles sound for all video elements.
         */
        function toggleSound() {
            isSoundOn = !isSoundOn;
            document.querySelectorAll('video').forEach(video => {
                video.muted = !isSoundOn;
            });
            if (bonnetSound) bonnetSound.muted = !isSoundOn;
            updateSoundButton();
        }
        
        /**
         * Updates the sound button's background image based on the sound state.
         */
        function updateSoundButton() {
            soundBtn.style.backgroundImage = isSoundOn ? "url('res/ui/vol_on.png')" : "url('res/ui/vol_off.png')";
        }

        // Add the event listener to the start button
        startButton.addEventListener('click', startExperience);
    </script>
</body>
</html>
